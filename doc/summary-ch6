6.1 트랜잭션이란 무엇인가?
영화표를 구입하는 과정을 예로 들어보자. 
관객이나 극장이 모두 손해를 보지 않으려면 영화표 구입과 관련된 모든 작업이 하나의 트랜잭션으로 묶여 있어야 한다.
트랜잭션으로 묶이면 이 작업들은 하나의 작업 처럼 취급되어 작업이 성공하거나, 
하나라도 실패하면 모든 작업이 취소되어 아무 일도 없었던 것처럼 롤백된다.
* 영화표 예매하기
1. 좌석 검사
2. 좌석 예약
3. 지불
4. 표 발행
트랜잭션은 소프트웨어에서 데이터나 리소스들의 무결성이 깨지지 않게 하는 중요한 역할을 담당한다.
무결성은 무엇인가?

6.1.1 ACID
Atomic(원자성) 
- 트랜잭션은 여러 개의 액티비티가 하나의 작업 단위로 묶인 것
- 원사성은 트랜잭션 내의 모든 작업이 일어나거나 하나도 일어나지 않을 것을 보장
- 모든 액티비티가 성공한다면 트랜잭션이 성공한 것
- 트랜잭션 내의 액티비티 중 하나라도 실패한다면 트랜잭션이 실패하고 롤백
Consistent(무결성)
- 트랜잭션이 종료되면 시스템은 그 시스템이 모델링한 비즈니스와 무결성의 상태를 유지한다.
- 데이터는 현실과 부정합을 일으키지 않아야 한다.
Isolated(격리성)
- 트랜잭션은 여러 명의 사용자가 동일한 데이터로 작업해도 각 사용자의 작업이 서로 뒤엉키지 않게 해야 한다.
- 트랜잭션은 동일한 데이터를 도시에 읽거나 쓰지 않도록 격리되어야 한다.
- 일반적으로 데이터베이스에 있는 테이블이나 행 잠금과 관련된다.
Durable(지속성)
- 트랜잭션이 완료되면 시스템이 이상이 생기더라도 트랜잭션의 결과가 영속돼야 한다.
- 이를 위해서 결과를 데이터베이스나 다른 형태의 영속적인 저장소에 저장해야 한다.
영화표 예제를 돌이켜 보면, 어느 한 단계라도 실패하면 모든 단계의 결과를 취소함으로써 원자성을 보장
원자성은 시스템의 데이터가 일관성을 잃고 부분적으로만 처리되지 않게 해준다.
표를 구입하는 동안 다른 트랜잭션이 좌석을 빼앗지 못하게 함으로써 격리성도 확보
이 모든 결과는 지속성을 가진 저장소에 저장되어 지속성을 갖게된다.

6.1.2 스프링의 트랜잭션 관리 지원
어떤 애플리케이션이 퍼스스턴스 자원(예:데이터베이스)를 단 하나만 사용하는 경우라면, 
스프링은 해당 퍼시스턴스 매커니즘이 제공하는 트랜잭션 기능을 활용해서 트랜잭션을 처리한다

선언적 트랜잭션(스프링 AOP를 기반으로 함)은 실제 작업과 트랜잭션 규칙을 분리
스프링의 선언적 트랜잭션은 격리 수준이나 타임아웃 가튼 추가적인 애트리뷰를 선언
- 코드 내에 트랜잭션을 작성하면 트랜잭션의 범위를 세밀하게 제어해서 원하는 곳에서 시작하고 끝낼 수 있음
- 일반적으로는 이처럼 세밀한 제어를 필요로 하는 경우가 많지 않기 때문에 보통은 트랜잭션을 컨텍스트 정의 파일에 선언하는 방법을 선택



6.4 트랜잭션 선언
스프링의 선언적 트랜잭션 관리는 스프링 AOP 프레임워크를 통해 구현
트랜잭션은 본래 애플리케이션의 주요 기능의 하부를 이루는 시스템 수준의 서비스
- 스프링 사용자 입장에서는 스프링 트랜잭션을 트랜잭션 경계로 메소드를 '둘러치는(wrap)' 애스펙트로 생각하는 것이 가장 이해하기 쉽다

6.4.1 트랜잭션 특성
선언적 트랜잭션은 
- 전파방식(propagation), 
- 격리 수준(isolation level), 
- 읽기전용 힌트(read-only hints),
- 타임아웃(timeout), 
- 롤백 규칙(rollback rules)
으로 정의

* propagation behavior (전파방식)
전파방식은 호출되는 메소드와 클라이언트에 대하여 트랜잭션의 경계를 정의
spring의 propagation의 default는 PROPAGATION_REQUIRED이다.
- PROPAGATION_REQUIRED 
: 해당 메소드는 트랜잭션 상황에서 실행돼야 한다.
: 이전에 실행되고 있는 트랜잭션이 없는 경우라면, 트랜잭션이 새로 시작되어야 한다.
- PROPAGATION_NESTED
: 이미 진행 중인 트랜잭션이 존재하면 해당 메소드는 중첩된 트랜잭션에서 실행되어야 한다.
: 중첩된 트랜잭션은 둘러싼 트랜잭션과 독립적으로 커밋되거나 롤백 될 수 있다.
: 만약 둘러싼 트랜잭션이 없는 상황이라면 이는 PROPAGATION_REQUIRED와 동일하게 동작한다. 
: 그러나 이 방식은 벤더에 의존적이며 지원이 안되는 경우가 많다.

* isolation level (트랜잭션 격리 수준)
격리 수준 = 한 트랜잭션이 동시에 진행 중인 다른 트랜잭션의 영향을 얼마나 받는가
트랜잭션 격리 수준 = 어떤 트랜잭션이 자신의 트랜잭션 데이터에 대해 얼마나 이기적인 입장을 취하는가

동시성에 의한 문제점
1. dirty read(더티 읽기)
- 한 트랜잭션에서 다른 트랜잭션에 의해 변경됐지만 아직 커밋되지는 않은 데이터를 읽게 되는 문제
- 이 데이터가 커밋되지 않고 롤백되어 버린다면, 첫 번째 트랜잭션에서 읽은 이 데이터는 유효하지 않은 데이터가 됨
2. nonrepeatable read(반복할 수 없는 읽기)
- 트랜잭션이 가튼 질의를 두 번 이상 수행할 때 서로 다른 테이터를 얻게 되는 문제를 말한다.
- 각 질의의 수행 사이에 동시 진행 중인 다른 트랜잭션에서 이 데이터를 변경하는 경우에 발생
3. phantom read(팬텀 읽기)
- nonrepeatable read와 유사함

완벽한 격리는 데이터 저장소의 데이터 행에 잠금(lock)을 걸거나 또는 전체 테이블에 잠금을 걸게 하므로 성능에 악영향을 끼친다
적극적인 잠금을 펼칠수록 동시성에 방해가 되는데 이는 트랜잭션들이 자신의 작업을 위해 다른 트랜잭션을 기다리게 하기 때문이다

* 격리 수준의 종류
- ISOLATION_DEFAULT
: 하부 데이터 저장소의 기본 격리 수준을 이용
- ISOLATION_READ_UNCOMMITTED
: 커밋되지 않은 데이터 변경사항을 읽을 수 있음
: 더티읽기, 반복할 수 없는 읽기, 팬텀 읽기를 허용
- ISOLATION_READ_COMMITTED
: 다른 트랜잭션이 커밋된 변경사항만 읽을 수 있도록 한다
: 더티 읽기는 방지되지만, 반복할 수 없는 읽기나 팬텀 읽기는 발생
- ISOLATION_REPEATABLE_READ
: 같은 데이터 필드는 여러 번 반복해서 읽더라도 동일한 값을 읽도록 한다
: 자신이 변경한 필드는 변경된 값을 읽게 된다
: 팬텀읽기는 여전히 발생
- ISOLATION_SERIALIZABLE
: 완전한 ACID를 보장하는 격리 수준으로 모든 문제점이 방지
: 트랜잭션에 관련된 모든 테이블을 잠그기 때문에 가장 성능 비효율적인 격리 수준

* 읽기 전용
선언적 트랜잭션의 세 번째요소
- 트랜잭션이 하부의 데이터 저장소에 대해 오직 읽기 작업만 수행한다면, 데이터 저장소에서는 트랜잭션의 읽기 전용 특성을 활용한 몇가지 최적화를 수행할 여지가 생김
- 트랜잭션을 읽기 전용으로 선언함으로써 데이터 저장소에게 최적화가 적절하다고 판달하고 최적화를 적용할 수 있는 기회를 제공
- 데이터 저장소는 트랜잭션이 시작할 때 읽기 전용 최적화를 수행한다.
-- 따라서 트랜잭션을 읽기 전용으로 선언할 때는 새로운 트랜잭션을 시작할 수 있는 전파방식(PROPAGATION_REQUIRED, PROPAGATION_REQUIRES_NEW, PROPAGATION_NESTED)에 선언해야 의미가 있음
